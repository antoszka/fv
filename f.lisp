;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; f.lisp – (c) 2010 Antoni Grzymała
;;;
;;; This is my personal invoicing program, might only ever be useful
;;; in the Polish VAT-invoice area.
;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; for now, the useful public interface of this is limited to:
;;; (add-to-db) used in conjunction with:
;;;   (make-client)
;;;   (make-item)
;;;   (make-invoice) used in conjunction with:
;;;     (select-by-nick)
;;;
;;; (read-db)
;;; (write-db)
;;; (print-invoice) in conjunction with:
;;;   (select-invoice-by-id)
;;;
;;; remaning are helper functions and similar crap

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; TODO:
;;; * removing entries from database
;;; * printing invoices (or creating .tex files rather)
;;;   * with cardinal numbers printed out in full (in Polish) ← somewhat „done”
;;;   * with net/gross calculations and groupings
;;; * selecting invoices by certain criteria
;;; * interactive mode (text UI) with browsing clients/items
;;; * command-line switches for scripting
;;; * corrective invoices
;;;
;;; --- later:
;;; * curses/tk/clim GUI
;;; * webgui
;;; * client/server (with android client)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; EXAMPLES:
;;; (make-invoice :client (select-by-nick :client 'asp) :items (select-by-nick :item 'adminowanie-asp))
;;; (make-invoice :client (select-by-nick :client 'asp) :items (adjust-key (select-by-nick 'adminowanie-asp :item) :count 2))
;;; (add-to-db (↑))

(require 'cl-emb)

;;;
;;; clhs appendf
;;;

(define-modify-macro appendf (&rest args)
  append "Append onto list")

;;;
;;; load Dodek's code for translating numbers to Polish:
;;;

(defvar *program-directory*
  (make-pathname
   :directory '(:absolute "home" "antoni" "fv")))

(load (compile-file (merge-pathnames
		     *program-directory*
		     (make-pathname :name "polish" :type "lisp"))))

;;; initialize the database and set default database filename:

(defvar *db* (list :item () :client () :invoice ()))
(defvar *db-file* (merge-pathnames (user-homedir-pathname) #P".fv.db"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Some needed functions
;;;

;;;
;;; following make-* functions return plists with our main types
;;; (item, client, invoice):
;;;

(defun make-item (&key title (vat 22) (count 1) net nick)
  "Create a single item inventory entry with a title, VAT, net price and nickname."
  (list
   :type  'item ; ← this tells us this is an item *db* entry
   :title title
   :vat   vat
   :count count
   :net   net
   :nick  nick))

(defun make-client (&key name address postcode (city "Warszawa")
		    nip email nick (payment-days 7))
  "Create a client inventory item with name, address, postcode, city, nip, e-mail and nick"
  (list
   :type         'client ; ← this tells us this is a client *db* entry
   :name         name
   :address      address
   :postcode     postcode
   :city         city
   :nip          nip
   :email        email
   :nick         nick
   :payment-days payment-days)) ; ← 0 means we want cash (7 is default)

(defun make-invoice (&key client items (payment-days 7)
		     year month date number)
  "Create an invoice with client, item list and date, payment type (not nil for cash) and payment days."
  (let* ((universal-time (get-universal-time))
	 (invoice-year   (or year   (getdate 'year  universal-time)))
	 (invoice-month  (or month  (getdate 'month universal-time)))
	 (invoice-date   (or date   (getdate 'date  universal-time)))
	 (invoice-number (or number (get-highest-number :for-month invoice-month :for-year invoice-year)))
	 (invoice-id     (format nil "FV-~d/~d/~d" invoice-number invoice-month invoice-year))) ; this
												; is
												; autogenerated
												; for
												; consistency
    ;; the above is to avoid a race-condition and make sure we create
    ;; a date in an atomic operation
    (list
     :type         'invoice
     :client       client
     :items        items
     :year         invoice-year
     :month        invoice-month
     :date         invoice-date
     :number       invoice-number
     :id           invoice-id
     :payment-days payment-days))) ; ← 0 means we want cash

;;;
;;; return nearest possible invoice number (for a given month/year)
;;;

(defun get-highest-number (&key for-month for-year)
  (let ((current-highest 0)
	(m for-month)
	(y for-year))
    (dolist (k (getf *db* :invoice))
      (cond ((and (eql (getf k :month) m)
		  (eql (getf k :year)  y))
	     (if (< current-highest (getf k :number))
		 (setf current-highest (getf k :number))
		 current-highest))))
    (1+ current-highest)))

;;;
;;; return some interesting date elements
;;;

(defun getdate (what-we-want universal-time)
  (nth-value
   (position what-we-want
	     '(second minute hour date month year day-of-week dst-p tz))
   (decode-universal-time universal-time)))

;;;
;;; return a database entry based upon nick and entry group (or an invoice by id)
;;; TODO – maybe consolidate the two, they're practically identical
;;;

(defun select-by-nick (group nick) 
  (dolist (k (getf *db* group))
    (if (eql (getf k :nick) nick)
	(return k)
	nil)))

(defun select-invoice-by-id (id)
  (dolist (k (getf *db* :invoice))
    (if (equal (getf k :id) id) ; equal!, we're comparing strings!
	(return k)
	nil)))

;;;
;;; function to adjust in-flight a key of a plist (with the intention
;;; of modifying :count when adding an item to an invoice
;;;

(defun adjust-key (plist key value)
  (setf (getf plist key) value)
  plist)

;;;
;;; check if NIP identification number is correct and non-nil
;;;

(defun correct-nip-p (nip)
  (if (let ((nip-string (format nil "~d" nip)))
	(when (= (length nip-string) 10)
	  (let ((checksum (loop for w in '(6 5 7 2 3 4 5 6 7)
			     for i across nip-string
			     sum (* w (digit-char-p i)))))
	    (= (digit-char-p (elt nip-string 9)) (rem checksum 11)))))
      nil t))

;;;
;;; add something to our database tree:
;;;

(defun add-to-db (entry)
  "Add anything to the db (in the right place) and do some verification tests."
  (let ((nick   (getf entry :nick))
	(nip    (getf entry :nip))
	(type   (getf entry :type))
	(id     (getf entry :id)))
    (cond
      ((equal type 'item)
       (when (or (select-by-nick nick :item) (not nick))
	   (error "~S already exists as an item nick or nick empty." nick))
       (push entry (getf *db* :item)))
      ((equal type 'client)
       (when (or (select-by-nick nick :client) (not nick))
	   (error "~S already exists as an item nick or nick empty." nick))
       (when (or (correct-nip-p nip) (not nip))
	   (error "~S is not a correct NIP number." nip))
       (push entry (getf *db* :client)))
      ((equal type 'invoice)
       (when (or (select-invoice-by-id id) (not id))
	   (error "~S already exists as an invoice id." id))
       (push entry (getf *db* :invoice)))
      (t nil))))

;;;
;;; dump stuff function (DEBUG)
;;;

(defun dump-db (type)
  "Quick view of the db (selected by type)"
  (dolist (db-entry (getf *db* type))
    (format t "~{~a:~10t~a~%~}~%" db-entry)))

;;;
;;; saving and loading the db
;;;

(defun write-db (&optional (pathname *db-file*))
  (with-open-file (output pathname
		       :direction :output
		       :if-exists :supersede)
    (with-standard-io-syntax
      (write *db* :case :downcase :pretty t :stream output) ; pretty-print database contents
      (format output "~%"))))                               ; add trailing newline

(defun read-db (&optional (pathname *db-file*))
  (with-open-file (input pathname
			 :direction :input)
    (with-standard-io-syntax
      (setf *db* (read input)))))

;;;
;;; calculate all necessary invoice fields
;;;

(defun calculate-invoice-fields (invoice)
  (let* ((gross-total       0)
	 (gross-total-int   0)
	 (gross-total-cent  0)
	 (net-total         0)
	 (vat-total         0)
	 (words-gross-total "")
	 (payment-days      (getf (getf invoice :client) :payment-days))
	 (invoice-date      (getf (getf invoice :client) :payment-days))
	 (invoice-month     (getf (getf invoice :client) :payment-days))
	 (invoice-year      (getf (getf invoice :client) :payment-days))
	 (payment-form      "")
	 (22-net-total      0)
	 (22-vat-total      0)
	 (22-gross-total    0)
	 (7-net-total       0)
	 (7-vat-total       0)
	 (7-gross-total     0)
	 (3-net-total       0)
	 (3-vat-total       0)
	 (3-gross-total     0)
	 (zw-net-total      0)
	 (calculated-items  nil))
    (dolist (item (list (getf invoice :items))) ;;; SERIO MA BYĆ LIST?
      (let* ((item-vat       (getf item :vat))
	     (item-count     (getf item :count))
	     (item-name      (getf item :name))
	     (item-net       (getf item :net))
	     (vat-multiplier (/ (if (equal item-vat "zw")
				    0
				    item-vat) 100.0)))
	(cond ((equal item-vat 22)   (incf 22-net-total   (* item-count item-net))
	       (incf 22-vat-total   (* item-count item-net 0.22))
	       (incf 22-gross-total (* item-count item-net 1.22)))
	      ((equal item-vat 7)    (incf 7-net-total    (* item-count item-net))
	       (incf 7-vat-total    (* item-count item-net 0.07))
	       (incf 7-gross-total  (* item-count item-net 1.07)))
	      ((equal item-vat 3)    (incf 3-net-total    (* item-count item-net))
	       (incf 3-vat-total    (* item-count item-net 0.03))
	       (incf 3-gross-total  (* item-count item-net 1.03)))
	      ((equal item-vat "zw") (incf zw-net-total   (* item-count item-net))))
	(push (list item-name
		    item-net
		    item-count
		    (* item-net item-count)
		    item-vat
		    (* item-net item-count vat-multiplier)
		    (* item-net item-count (1+ vat-multiplier)))
	      calculated-items)))
    (setq gross-total (+ 22-gross-total 7-gross-total 3-gross-total zw-net-total))
    (setq net-total   (+ 22-net-total   7-net-total   3-net-total   zw-net-total))
    (setq vat-total   (+ 22-vat-total   7-vat-total   3-vat-total))
    (multiple-value-bind (int cent)
	(floor gross-total)
      (setq gross-total-int  int)
      (setq gross-total-cent cent))
    (setq words-gross-total (with-output-to-string (words)
			      (format-print-cardinal words gross-total)))
    (setq payment-form
	  (if (<= payment-days 0)
	      "Płatność gotówką."
	      (multiple-value-bind (a b c day month year d e f)
		  (decode-universal-time
		   (+ (* payment-days 86400)
		      (encode-universal-time
		       0 0 0 invoice-date invoice-month invoice-year)))
		(declare (ignore a b c d e f))
		(format nil
			"Płatność przelewem do dnia: ~d/~d/~d (~d dni)."
			day month year payment-days))))
    (list :gross-total       gross-total
	  :gross-total-int   gross-total-int
	  :gross-total-cent  gross-total-cent
	  :net-total         net-total
	  :vat-total         vat-total
	  :words-gross-total words-gross-total
	  :payment-days      payment-days
	  :invoice-date      invoice-date
	  :invoice-month     invoice-month
	  :invoice-year      invoice-year
	  :payment-form      payment-form
	  :22-net-total      22-net-total
	  :22-vat-total      22-vat-total
	  :22-gross-total    22-gross-total
	  :7-net-total       7-net-total
	  :7-vat-total       7-vat-total
	  :7-gross-total     7-gross-total
	  :3-net-total       3-net-total
	  :3-vat-total       3-vat-total
	  :3-gross-total     3-gross-total
	  :zw-net-total      zw-net-total
	  :calculated-items  calculated-items)))

;;;
;;; printing an invoice
;;; date calculation hint:
;;;

(defun print-invoice (invoice)
  (let* ((env-plist
	  (list :invoice-id        (getf invoice :id)
		:invoice-date-full (format nil "~a/~a/~a"
					   (getf invoice :date)
					   (getf invoice :month)
					   (getf invoice :year))
		:buyer-name        (getf (getf invoice :client) :name)
		:buyer-address     (getf (getf invoice :client) :address)
		:buyer-postcode    (getf (getf invoice :client) :postcode)
		:buyer-nip         (getf (getf invoice :client) :nip)
		:item-list         (getf invoice :items)))
	 (output-filename (merge-pathnames
			   (user-homedir-pathname)
			   (format nil "fv-~d-~d-~d-~a.tex"
				   (getf invoice :year)
				   (getf invoice :month)
				   (getf invoice :number)
				   (getf (getf invoice :client) :nick)))))
    (emb:register-emb "template" (merge-pathnames *program-directory*
						  (make-pathname :name "emb-template"
								 :type "tex")))
    (with-open-file (output (merge-pathnames (user-homedir-pathname) output-filename)
			    :direction :output
			    :if-exists :supersede)
      (format output "~a"
	      (emb:execute-emb "template"
			       :env (append env-plist (calculate-invoice-fields invoice)))))))
