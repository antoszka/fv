;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; f.lisp – (c) 2010 Antoni Grzymała
;;;
;;; This is my personal invoicing program, might only ever be useful
;;; in the Polish VAT-invoice area.
;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; for now, the useful public interface of this is limited to:
;;; (add-to-db) used in conjunction with:
;;;   (make-client)
;;;   (make-item)
;;;   (make-invoice) used in conjunction with:
;;;     (select-by-nick)
;;;
;;; (read-db)
;;; (write-db)
;;; (print-invoice) in conjunction with:
;;;   (select-invoice-by-id)
;;;
;;; remaning are helper functions and similar crap

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; TODO:
;;; * removing entries from database
;;; * printing invoices (or creating .tex files rather)
;;;   * with cardinal numbers printed out in full (in Polish) ← somewhat „done”
;;;   * with net/gross calculations and groupings
;;; * selecting invoices by certain criteria
;;; * interactive mode (text UI) with browsing clients/items
;;; * command-line switches for scripting
;;; * corrective invoices
;;;
;;; --- later:
;;; * curses/tk/clim GUI
;;; * webgui
;;; * client/server (with android client)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; EXAMPLES:
;;; (make-invoice :client (select-by-nick :client 'asp) :items (select-by-nick :item 'adminowanie-asp))
;;; (make-invoice :client (select-by-nick :client 'asp) :items (adjust-key (select-by-nick 'adminowanie-asp :item) :count 2))
;;; (add-to-db (↑))

;;;
;;; load Dodek's code for translating numbers to Polish:
;;;

(defvar *program-directory*
  (make-pathname
   :directory '(:absolute "home" "antoni" "fv")))

(load (compile-file (merge-pathnames
		     *program-directory*
		     (make-pathname :name "polish" :type "lisp"))))

;;; initialize the database and set default database filename:

(defvar *db* (list :item () :client () :invoice ()))
(defvar *db-file* (merge-pathnames (user-homedir-pathname) #P".fv.db"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Some needed functions
;;;

;;;
;;; following make-* functions return plists with our main types
;;; (item, client, invoice):
;;;

(defun make-item (&key title (vat 22) (count 1) net nick)
  "Create a single item inventory entry with a title, VAT, net price and nickname."
  (list
   :type  'item ; ← this tells us this is an item *db* entry
   :title title
   :vat   vat
   :count count
   :net   net
   :nick  nick))

(defun make-client (&key name address postcode (city "Warszawa")
		    nip email nick payment-cash (payment-days 7))
  "Create a client inventory item with name, address, postcode, city, nip, e-mail and nick"
  (list
   :type         'client ; ← this tells us this is a client *db* entry
   :name         name
   :address      address
   :postcode     postcode
   :city         city
   :nip          nip
   :email        email
   :nick         nick
   :payment-cash payment-cash ; ← nil (default) means we want a bank transfer
   :payment-days payment-days))

(defun make-invoice (&key client items payment-cash
		     (payment-days 7) year month date number)
  "Create an invoice with client, item list and date, payment type (not nil for cash) and payment days."
  (let* ((universal-time (get-universal-time))
	 (invoice-year   (or year   (getdate 'year  universal-time)))
	 (invoice-month  (or month  (getdate 'month universal-time)))
	 (invoice-date   (or date   (getdate 'date  universal-time)))
	 (invoice-number (or number (get-highest-number :for-month invoice-month :for-year invoice-year)))
	 (invoice-id     (format nil "FV-~d/~d/~d" invoice-number invoice-month invoice-year))) ; this
												; is
												; autogenerated
												; for
												; consistency
    ;; the above is to avoid a race-condition and make sure we create
    ;; a date in an atomic operation
    (list
     :type         'invoice
     :client       client
     :items        items
     :year         invoice-year
     :month        invoice-month
     :date         invoice-date
     :number       invoice-number
     :id           invoice-id
     :payment-cash payment-cash	; ← nil means we want a money transfer
     :payment-days payment-days)))

;;;
;;; return nearest possible invoice number (for a given month/year)
;;;

(defun get-highest-number (&key for-month for-year)
  (let ((current-highest 0)
	(m for-month)
	(y for-year))
    (dolist (k (getf *db* :invoice))
      (cond ((and (eql (getf k :month) m)
		  (eql (getf k :year)  y))
	     (if (< current-highest (getf k :number))
		 (setf current-highest (getf k :number))
		 current-highest))))
    (1+ current-highest)))

;;;
;;; return some interesting date elements
;;;

(defun getdate (what-we-want universal-time)
  (nth-value
   (position what-we-want
	     '(second minute hour date month year day-of-week dst-p tz))
   (decode-universal-time universal-time)))

;;;
;;; return a database entry based upon nick and entry group (or an invoice by id)
;;; TODO – maybe consolidate the two, they're practically identical
;;;

(defun select-by-nick (group nick) 
  (dolist (k (getf *db* group))
    (if (eql (getf k :nick) nick)
	(return k)
	nil)))

(defun select-invoice-by-id (id)
  (dolist (k (getf *db* :invoice))
    (if (equal (getf k :id) id) ; equal!, we're comparing strings!
	(return k)
	nil)))

;;;
;;; function to adjust in-flight a key of a plist (with the intention
;;; of modifying :count when adding an item to an invoice
;;;

(defun adjust-key (plist key value)
  (setf (getf plist key) value)
  plist)

;;;
;;; check if NIP identification number is correct and non-nil
;;;

(defun correct-nip-p (nip)
  (if (let ((nip-string (format nil "~d" nip)))
	(when (= (length nip-string) 10)
	  (let ((checksum (loop for w in '(6 5 7 2 3 4 5 6 7)
			     for i across nip-string
			     sum (* w (digit-char-p i)))))
	    (= (digit-char-p (elt nip-string 9)) (rem checksum 11)))))
      nil t))

;;;
;;; add something to our database tree:
;;;

(defun add-to-db (entry)
  "Add anything to the db (in the right place) and do some verification tests."
  (let ((nick   (getf entry :nick))
	(nip    (getf entry :nip))
	(type   (getf entry :type))
	(id     (getf entry :id)))
    (cond
      ((equal type 'item)
       (if (or (select-by-nick nick :item) (not nick))
	   (error "~S already exists as an item nick or nick empty." nick)
	   t)
       (push entry (getf *db* :item)))
      ((equal type 'client)
       (if (or (select-by-nick nick :client) (not nick))
	   (error "~S already exists as an item nick or nick empty." nick)
	   t)
       (if (or (correct-nip-p nip) (not nip))
	   (error "~S is not a correct NIP number." nip)
	   t)
       (push entry (getf *db* :client)))
      ((equal type 'invoice)
       (if (or (select-invoice-by-id id) (not id))
	   (error "~S already exists as an invoice id." id)
	   t)
       (push entry (getf *db* :invoice)))
      (t nil))))

;;;
;;; dump stuff function
;;;

(defun dump-db (type)
  "Quick view of the db (selected by type)"
  (dolist (db-entry (getf *db* type))
    (format t "~{~a:~10t~a~%~}~%" db-entry)))

;;;
;;; saving and loading the db
;;;

(defun write-db (&optional (pathname *db-file*))
  (with-open-file (output pathname
		       :direction :output
		       :if-exists :supersede)
    (with-standard-io-syntax
      (write *db* :case :downcase :pretty t :stream output) ; pretty-print database contents
      (format output "~%"))))                               ; add trailing newline

(defun read-db (&optional (pathname *db-file*))
  (with-open-file (input pathname
			 :direction :input)
    (with-standard-io-syntax
      (setf *db* (read input)))))

;;;
;;; printing an invoice
;;; date calculation hint:
;;;   (decode-universal-time (+ (* 14 86400) (encode-universal-time 0 0 0 28 8 2010)))
;;;

(defun print-invoice (invoice)
  (require 'cl-emb)
  (let* ((env-plist
	  (list :invoice-id        (getf invoice :id)
		:invoice-date-full (format nil "~a/~a/~a"
					   (getf invoice :date)
					   (getf invoice :month)
					   (getf invoice :year))
		:buyer-name        (getf (getf invoice :client) :name)
		:buyer-address     (getf (getf invoice :client) :address)
		:buyer-postcode    (getf (getf invoice :client) :postcode)
		:buyer-nip         (getf (getf invoice :client) :nip)
		:item-list         (getf invoice :items)))
	 (output-filename   (merge-pathnames
			     (user-homedir-pathname)
			     (format nil "fv-~d-~d-~d-~a.tex"
				     (getf invoice :number)
				     (getf invoice :month)
				     (getf invoice :year)
				     (getf (getf invoice :client) :nick)))))
    (emb:register-emb "template" (merge-pathnames *program-directory*
						  (make-pathname :name "emb-template"
								 :type "tex")))
    (with-open-file (output (merge-pathnames (user-homedir-pathname)
					     output-filename)
			    :direction :output
			    :if-exists :supersede)
      (format output "~a" (emb:execute-emb "template" :env env-plist)))))
